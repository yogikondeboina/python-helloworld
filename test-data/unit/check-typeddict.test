-- Create Instance

[case testCanCreateTypedDictInstanceWithKeywordArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[targets __main__]

[case testCanCreateTypedDictInstanceWithDictCall]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithDictLiteral]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point({'x': 42, 'y': 1337})
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithNoArguments]
from typing import TypeVar, Union
from mypy_extensions import TypedDict
EmptyDict = TypedDict('EmptyDict', {})
p = EmptyDict()
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.EmptyDict', {})"
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Create Instance (Errors)

[case testCannotCreateTypedDictInstanceWithUnknownArgumentPattern]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(42, 1337)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceNonLiteralItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
x = 'x'
p = Point({x: 42, 'y': 1337})  # E: Expected TypedDict key to be string literal
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithExtraItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337, z=666)  # E: Extra key "z" for TypedDict "Point"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithMissingItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42)  # E: Missing key "y" for TypedDict "Point"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithIncompatibleItemType]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x='meaning_of_life', y=1337)  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithInlineTypedDict]
from mypy_extensions import TypedDict
D = TypedDict('D', {
    'x': TypedDict('E', {  # E: Inline TypedDict types not supported; use assignment to define TypedDict
        'y': int
    })
})
[builtins fixtures/dict.pyi]

-- Define TypedDict (Class syntax)

[case testCanCreateTypedDictWithClass]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithSubclass]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(Point1D):
    y: int
r: Point1D
p: Point2D
reveal_type(r)  # N: Revealed type is "TypedDict('__main__.Point1D', {'x': builtins.int})"
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithSubclass2]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(TypedDict, Point1D): # We also allow to include TypedDict in bases, it is simply ignored at runtime
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictClassEmpty]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class EmptyDict(TypedDict):
    pass

p = EmptyDict()
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.EmptyDict', {})"
[builtins fixtures/dict.pyi]


[case testCanCreateTypedDictWithClassOldVersion]
# flags: --python-version 3.5

# Test that we can use class-syntax to merge TypedDicts even in
# versions without type annotations

from mypy_extensions import TypedDict

MovieBase1 = TypedDict(
    'MovieBase1', {'name': str, 'year': int})
MovieBase2 = TypedDict(
    'MovieBase2', {'based_on': str}, total=False)

class Movie(MovieBase1, MovieBase2):
    pass

def foo(x):
    # type: (Movie) -> None
    pass

foo({})  # E: Missing keys ("name", "year") for TypedDict "Movie"
foo({'name': 'lol', 'year': 2009, 'based_on': 0})  # E: Incompatible types (expression has type "int", TypedDict item "based_on" has type "str")

[builtins fixtures/dict.pyi]

-- Define TypedDict (Class syntax errors)

[case testCannotCreateTypedDictWithClassOtherBases]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class A: pass

class Point1D(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Point2D(Point1D, A): # E: All bases of a new TypedDict must be TypedDict types
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithDuplicateBases]
# https://github.com/python/mypy/issues/3673
from typing import TypedDict

class A(TypedDict):
    x: str
    y: int

class B(A, A): # E: Duplicate base class "A"
    z: str

class C(TypedDict, TypedDict): # E: Duplicate base class "TypedDict"
    c1: int
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithClassWithOtherStuff]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int = 1 # E: Right hand side values are not supported in TypedDict
    def f(): pass # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    z = int # E: Invalid statement in TypedDict definition; expected "field_name: field_type"

p = Point(x=42, y=1337, z='whatever')
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int, 'z': Any})"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithClassWithFunctionUsedToCrash]
# https://github.com/python/mypy/issues/11079
from typing import TypedDict
class D(TypedDict):
    y: int
    def x(self, key: int):  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
        pass

d = D(y=1)
reveal_type(d)  # N: Revealed type is "TypedDict('__main__.D', {'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithDecoratedFunction]
# flags: --disallow-any-expr
# https://github.com/python/mypy/issues/13066
from typing import TypedDict
class D(TypedDict):
    @classmethod  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    def m(self) -> D:
        pass
d = D()
reveal_type(d)  # N: Revealed type is "TypedDict('__main__.D', {})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithClassmethodAlternativeConstructorDoesNotCrash]
# https://github.com/python/mypy/issues/5653
from typing import TypedDict

class Foo(TypedDict):
    bar: str
    @classmethod  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    def baz(cls) -> "Foo": ...
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictTypeWithUnderscoreItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int, '_fallback': object})
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithClassUnderscores]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    _y: int

p: Point
reveal_type(p) # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, '_y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey1]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Bad(TypedDict):
    x: int
    x: str # E: Duplicate TypedDict key "x"

b: Bad
reveal_type(b) # N: Revealed type is "TypedDict('__main__.Bad', {'x': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey2]
from typing import TypedDict

D1 = TypedDict("D1", {
    "x": int,
    "x": int,  # E: Duplicate TypedDict key "x"
})
D2 = TypedDict("D2", {"x": int, "x": str})  # E: Duplicate TypedDict key "x"

d1: D1
d2: D2
reveal_type(d1) # N: Revealed type is "TypedDict('__main__.D1', {'x': builtins.int})"
reveal_type(d2) # N: Revealed type is "TypedDict('__main__.D2', {'x': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithClassOverwriting]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1(TypedDict):
    x: int
class Point2(TypedDict):
    x: float
class Bad(Point1, Point2): # E: Overwriting TypedDict field "x" while merging
    pass

b: Bad
reveal_type(b) # N: Revealed type is "TypedDict('__main__.Bad', {'x': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithClassOverwriting2]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1(TypedDict):
    x: int
class Point2(Point1):
    x: float # E: Overwriting TypedDict field "x" while extending

p2: Point2
reveal_type(p2) # N: Revealed type is "TypedDict('__main__.Point2', {'x': builtins.float})"
[builtins fixtures/dict.pyi]


-- Subtyping

[case testCanConvertTypedDictToItself]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def identity(p: Point) -> Point:
    return p
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToEquivalentTypedDict]
from mypy_extensions import TypedDict
PointA = TypedDict('PointA', {'x': int, 'y': int})
PointB = TypedDict('PointB', {'x': int, 'y': int})
def identity(p: PointA) -> PointB:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithNarrowerItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(op: ObjectPoint) -> Point:
    return op  # E: Incompatible return value type (got "ObjectPoint", expected "Point")
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithWiderItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(p: Point) -> ObjectPoint:
    return p  # E: Incompatible return value type (got "Point", expected "ObjectPoint")
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithIncompatibleItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Chameleon = TypedDict('Chameleon', {'x': str, 'y': str})
def convert(p: Point) -> Chameleon:
    return p  # E: Incompatible return value type (got "Point", expected "Chameleon")
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToNarrowerTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point1D = TypedDict('Point1D', {'x': int})
def narrow(p: Point) -> Point1D:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToWiderTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
def widen(p: Point) -> Point3D:
    return p  # E: Incompatible return value type (got "Point", expected "Point3D")
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToCompatibleMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, object]:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToIncompatibleMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Mapping[str, int]")
[builtins fixtures/dict.pyi]

[case testTypedDictAcceptsIntForFloatDuckTypes]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point() -> Point:
    return Point(x=1, y=2)
reveal_type(Point(x=1, y=2))  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.float, 'y': builtins.float})"
[builtins fixtures/dict.pyi]

[case testTypedDictDoesNotAcceptsFloatForInt]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def create_point() -> Point:
    return Point(x=1.2, y=2.5)
[out]
main:5: error: Incompatible types (expression has type "float", TypedDict item "x" has type "int")
main:5: error: Incompatible types (expression has type "float", TypedDict item "y" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictAcceptsAnyType]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point(something: Any) -> Point:
    return Point({
      'x': something.x,
      'y': something.y
    })
[builtins fixtures/dict.pyi]

[case testTypedDictValueTypeContext]
from mypy_extensions import TypedDict
from typing import List
D = TypedDict('D', {'x': List[int]})
reveal_type(D(x=[]))  # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.list[builtins.int]})"
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToDictOrMutableMapping]
from mypy_extensions import TypedDict
from typing import Dict, MutableMapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_dict(p: Point) -> Dict[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Dict[str, int]")
def as_mutable_mapping(p: Point) -> MutableMapping[str, object]:
    return p  # E: Incompatible return value type (got "Point", expected "MutableMapping[str, object]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testCanConvertTypedDictToAny]
from mypy_extensions import TypedDict
from typing import Any
Point = TypedDict('Point', {'x': int, 'y': int})
def unprotect(p: Point) -> Any:
    return p
[builtins fixtures/dict.pyi]

[case testAnonymousTypedDictInErrorMessages]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': int, 'z': str, 'a': int})
C = TypedDict('C', {'x': int, 'z': str, 'a': str})
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int, 'z': str})]"; expected "A"
[builtins fixtures/dict.pyi]

[case testTypedDictWithSimpleProtocol]
from typing_extensions import Protocol, TypedDict

class StrObjectMap(Protocol):
    def __getitem__(self, key: str) -> object: ...
class StrIntMap(Protocol):
    def __getitem__(self, key: str) -> int: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrObjectMap) -> None: ...
def fun2(arg: StrIntMap) -> None: ...
a: A
b: B
fun(a)
fun(b)
fun2(a) # Error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:17: error: Argument 1 to "fun2" has incompatible type "A"; expected "StrIntMap"
main:17: note: Following member(s) of "A" have conflicts:
main:17: note:     Expected:
main:17: note:         def __getitem__(self, str, /) -> int
main:17: note:     Got:
main:17: note:         def __getitem__(self, str, /) -> object

[case testTypedDictWithSimpleProtocolInference]
from typing_extensions import Protocol, TypedDict
from typing import TypeVar

T_co = TypeVar('T_co', covariant=True)
T = TypeVar('T')

class StrMap(Protocol[T_co]):
    def __getitem__(self, key: str) -> T_co: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrMap[T]) -> T:
    return arg['whatever']
a: A
b: B
reveal_type(fun(a))  # N: Revealed type is "builtins.object"
reveal_type(fun(b))  # N: Revealed type is "builtins.object"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Join

[case testJoinOfTypedDictHasOnlyCommonKeysAndNewFallback]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
p1 = TaggedPoint(type='2d', x=0, y=0)
p2 = Point3D(x=1, y=1, z=1)
joined_points = [p1, p2][0]
reveal_type(p1.values())   # N: Revealed type is "typing.Iterable[builtins.object]"
reveal_type(p2.values())   # N: Revealed type is "typing.Iterable[builtins.object]"
reveal_type(joined_points)  # N: Revealed type is "TypedDict({'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictRemovesNonequivalentKeys]
from mypy_extensions import TypedDict
CellWithInt = TypedDict('CellWithInt', {'value': object, 'meta': int})
CellWithObject = TypedDict('CellWithObject', {'value': object, 'meta': object})
c1 = CellWithInt(value=1, meta=42)
c2 = CellWithObject(value=2, meta='turtle doves')
joined_cells = [c1, c2]
reveal_type(c1)             # N: Revealed type is "TypedDict('__main__.CellWithInt', {'value': builtins.object, 'meta': builtins.int})"
reveal_type(c2)             # N: Revealed type is "TypedDict('__main__.CellWithObject', {'value': builtins.object, 'meta': builtins.object})"
reveal_type(joined_cells)   # N: Revealed type is "builtins.list[TypedDict({'value': builtins.object})]"
[builtins fixtures/dict.pyi]

[case testJoinOfDisjointTypedDictsIsEmptyTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Cell = TypedDict('Cell', {'value': object})
d1 = Point(x=0, y=0)
d2 = Cell(value='pear tree')
joined_dicts = [d1, d2]
reveal_type(d1)             # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
reveal_type(d2)             # N: Revealed type is "TypedDict('__main__.Cell', {'value': builtins.object})"
reveal_type(joined_dicts)   # N: Revealed type is "builtins.list[TypedDict({})]"
[builtins fixtures/dict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingIsMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Mapping[str, int]
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[typing.Mapping[builtins.str, builtins.object]]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[typing.Mapping[builtins.str, builtins.object]]"
[builtins fixtures/dict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingSupertypeIsSupertype]
from mypy_extensions import TypedDict
from typing import Sized
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Sized
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[typing.Sized]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[typing.Sized]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictWithIncompatibleTypeIsObject]
from mypy_extensions import TypedDict
from typing import Mapping
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = 42
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[builtins.object]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[builtins.object]"
[builtins fixtures/dict.pyi]


-- Meet

[case testMeetOfTypedDictsWithCompatibleCommonKeysHasAllKeysAndNewFallback]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int})
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x': builtins.int, 'y': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithIncompatibleCommonKeysIsUninhabited]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XYa = TypedDict('XYa', {'x': int, 'y': int})
YbZ = TypedDict('YbZ', {'y': object, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XYa, y: YbZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "<nothing>"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNoCommonKeysHasAllKeysAndNewFallback]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
X = TypedDict('X', {'x': int})
Z = TypedDict('Z', {'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: Z) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]

# TODO: It would be more accurate for the meet to be TypedDict instead.
[case testMeetOfTypedDictWithCompatibleMappingIsUninhabitedForNow]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, int]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is "<nothing>"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictWithIncompatibleMappingIsUninhabited]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is "<nothing>"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictWithCompatibleMappingSuperclassIsUninhabitedForNow]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Iterable
X = TypedDict('X', {'x': int})
I = Iterable[str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: I) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict('__main__.X', {'x': builtins.int})"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNonTotal]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int}, total=False)
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y'?: builtins.int, 'z'?: builtins.int})"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNonTotalAndTotal]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithIncompatibleNonTotalAndTotal]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g)) # N: Revealed type is "<nothing>"
[builtins fixtures/dict.pyi]


-- Constraint Solver

[case testTypedDictConstraintsAgainstIterable]
from typing import TypeVar, Iterable
from mypy_extensions import TypedDict
T = TypeVar('T')
def f(x: Iterable[T]) -> T: pass
A = TypedDict('A', {'x': int})
a: A
reveal_type(f(a)) # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- TODO: Figure out some way to trigger the ConstraintBuilderVisitor.visit_typeddict_type() path.


-- Special Method: __getitem__

[case testCanGetItemOfTypedDictWithValidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
reveal_type(p['type'])  # N: Revealed type is "builtins.str"
reveal_type(p['x'])     # N: Revealed type is "builtins.int"
reveal_type(p['y'])     # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testCannotGetItemOfTypedDictWithInvalidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p: TaggedPoint
p['typ']  # E: TypedDict "TaggedPoint" has no key "typ" \
          # N: Did you mean "type"?
[builtins fixtures/dict.pyi]

[case testCannotGetItemOfAnonymousTypedDictWithInvalidStringLiteralKey]
from typing import TypeVar
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': str, 'y': int, 'z': str})
B = TypedDict('B', {'x': str, 'z': int})
C = TypedDict('C', {'x': str, 'y': int, 'z': int})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x='', y=1, z=''), B(x='', z=1))
ac = join(A(x='', y=1, z=''), C(x='', y=0, z=1))
ab['y']  # E: "y" is not a valid TypedDict key; expected one of ("x")
ac['a']  # E: "a" is not a valid TypedDict key; expected one of ("x", "y")
[builtins fixtures/dict.pyi]

[case testCannotGetItemOfTypedDictWithNonLiteralKey]
from mypy_extensions import TypedDict
from typing import Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def get_coordinate(p: TaggedPoint, key: str) -> Union[str, int]:
    return p[key]  # E: TypedDict key must be a string literal; expected one of ("type", "x", "y")
[builtins fixtures/dict.pyi]


-- Special Method: __setitem__

[case testCanSetItemOfTypedDictWithValidStringLiteralKeyAndCompatibleValueType]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['type'] = 'two_d'
p['x'] = 1
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithIncompatibleValueType]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['x'] = 'y'  # E: Value of "x" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithInvalidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['z'] = 1  # E: TypedDict "TaggedPoint" has no key "z"
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithNonLiteralKey]
from mypy_extensions import TypedDict
from typing import Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def set_coordinate(p: TaggedPoint, key: str, value: int) -> None:
    p[key] = value  # E: TypedDict key must be a string literal; expected one of ("type", "x", "y")
[builtins fixtures/dict.pyi]


-- isinstance

[case testTypedDictWithIsInstanceAndIsSubclass]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int})
d: object
if isinstance(d, D):   # E: Cannot use isinstance() with TypedDict type
    reveal_type(d)     # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int})"
issubclass(object, D)  # E: Cannot use issubclass() with TypedDict type
[builtins fixtures/isinstancelist.pyi]


-- Scoping

[case testTypedDictInClassNamespace]
# https://github.com/python/mypy/pull/2553#issuecomment-266474341
from mypy_extensions import TypedDict
class C:
    def f(self):
        A = TypedDict('A', {'x': int})
    def g(self):
        A = TypedDict('A', {'y': int})
C.A  # E: "Type[C]" has no attribute "A"
[builtins fixtures/dict.pyi]

[case testTypedDictInFunction]
from mypy_extensions import TypedDict
def f() -> None:
    A = TypedDict('A', {'x': int})
A  # E: Name "A" is not defined
[builtins fixtures/dict.pyi]


-- Union simplification / proper subtype checks

[case testTypedDictUnionSimplification]
from typing import TypeVar, Union, Any, cast
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int})
D = TypedDict('D', {'a': int, 'b': int})
E = TypedDict('E', {'a': str})
F = TypedDict('F', {'x': int})
G = TypedDict('G', {'a': Any})

c = C(a=1)
d = D(a=1, b=1)
e = E(a='')
f = F(x=1)
g = G(a=cast(Any, 1))  # Work around #2610

reveal_type(u(d, d)) # N: Revealed type is "TypedDict('__main__.D', {'a': builtins.int, 'b': builtins.int})"
reveal_type(u(c, d)) # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
reveal_type(u(d, c)) # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
reveal_type(u(c, e)) # N: Revealed type is "Union[TypedDict('__main__.E', {'a': builtins.str}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(e, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.E', {'a': builtins.str})]"
reveal_type(u(c, f)) # N: Revealed type is "Union[TypedDict('__main__.F', {'x': builtins.int}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(f, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.F', {'x': builtins.int})]"
reveal_type(u(c, g)) # N: Revealed type is "Union[TypedDict('__main__.G', {'a': Any}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(g, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.G', {'a': Any})]"
[builtins fixtures/dict.pyi]

[case testTypedDictUnionSimplification2]
from typing import TypeVar, Union, Mapping, Any
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int, 'b': int})

c = C(a=1, b=1)
m_s_o: Mapping[str, object]
m_s_s: Mapping[str, str]
m_i_i: Mapping[int, int]
m_s_a: Mapping[str, Any]

reveal_type(u(c, m_s_o)) # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(u(m_s_o, c)) # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(u(c, m_s_s)) # N: Revealed type is "Union[typing.Mapping[builtins.str, builtins.str], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
reveal_type(u(c, m_i_i)) # N: Revealed type is "Union[typing.Mapping[builtins.int, builtins.int], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
reveal_type(u(c, m_s_a)) # N: Revealed type is "Union[typing.Mapping[builtins.str, Any], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
[builtins fixtures/dict.pyi]

[case testTypedDictUnionUnambiguousCase]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'a': str})
B = TypedDict('B', {'@type': Literal['b-type'], 'b': int})

c: Union[A, B] = {'@type': 'a-type', 'a': 'Test'}
reveal_type(c) # N: Revealed type is "Union[TypedDict('__main__.A', {'@type': Literal['a-type'], 'a': builtins.str}), TypedDict('__main__.B', {'@type': Literal['b-type'], 'b': builtins.int})]"
[builtins fixtures/dict.pyi]

[case testTypedDictUnionAmbiguousCaseBothMatch]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'value': str})
B = TypedDict('B', {'@type': Literal['b-type'], 'value': str})

c: Union[A, B] = {'@type': 'a-type', 'value': 'Test'}
[builtins fixtures/dict.pyi]

[case testTypedDictUnionAmbiguousCaseNoMatch]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'value': int})
B = TypedDict('B', {'@type': Literal['b-type'], 'value': int})

c: Union[A, B] = {'@type': 'a-type', 'value': 'Test'}  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                                                       # E: Incompatible types in assignment (expression has type "Dict[str, str]", variable has type "Union[A, B]")
[builtins fixtures/dict.pyi]

-- Use dict literals

[case testTypedDictDictLiterals]
from mypy_extensions import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

def f(p: Point) -> None:
    if int():
        p = {'x': 2, 'y': 3}
        p = {'x': 2}  # E: Missing key "y" for TypedDict "Point"
        p = dict(x=2, y=3)

f({'x': 1, 'y': 3})
f({'x': 1, 'y': 'z'})  # E: Incompatible types (expression has type "str", TypedDict item "y" has type "int")

f(dict(x=1, y=3))
f(dict(x=1, y=3, z=4))  # E: Extra key "z" for TypedDict "Point"
f(dict(x=1, y=3, z=4, a=5))  # E: Extra keys ("z", "a") for TypedDict "Point"

[builtins fixtures/dict.pyi]

[case testTypedDictExplicitTypes]
from mypy_extensions import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

p1a: Point = {'x': 'hi'}  # E: Missing key "y" for TypedDict "Point"
p1b: Point = {}           # E: Missing keys ("x", "y") for TypedDict "Point"

p2: Point
p2 = dict(x='bye')  # E: Missing key "y" for TypedDict "Point"

p3 = Point(x=1, y=2)
if int():
    p3 = {'x': 'hi'}  # E: Missing key "y" for TypedDict "Point"

p4: Point = {'x': 1, 'y': 2}

[builtins fixtures/dict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithExtraItems]
from mypy_extensions import TypedDict
from typing import TypeVar
A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1), B(x=1, y=''))
if int():
    ab = {'x': 1, 'z': 1} # E: Expected TypedDict key "x" but found keys ("x", "z")
[builtins fixtures/dict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithMissingItems]
from mypy_extensions import TypedDict
from typing import TypeVar
A = TypedDict('A', {'x': int, 'y': int, 'z': int})
B = TypedDict('B', {'x': int, 'y': int, 'z': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1, z=1), B(x=1, y=1, z=''))
if int():
    ab = {} # E: Expected TypedDict keys ("x", "y") but found no keys
[builtins fixtures/dict.pyi]


-- Other TypedDict methods

[case testTypedDictGetMethod]
# flags: --strict-optional
from mypy_extensions import TypedDict
class A: pass
D = TypedDict('D', {'x': int, 'y': str})
d: D
reveal_type(d.get('x')) # N: Revealed type is "Union[builtins.int, None]"
reveal_type(d.get('y')) # N: Revealed type is "Union[builtins.str, None]"
reveal_type(d.get('x', A())) # N: Revealed type is "Union[builtins.int, __main__.A]"
reveal_type(d.get('x', 1)) # N: Revealed type is "builtins.int"
reveal_type(d.get('y', None)) # N: Revealed type is "Union[builtins.str, None]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodTypeContext]
# flags: --strict-optional
from typing import List
from mypy_extensions import TypedDict
class A: pass
D = TypedDict('D', {'x': List[int], 'y': int})
d: D
reveal_type(d.get('x', [])) # N: Revealed type is "builtins.list[builtins.int]"
d.get('x', ['x']) # E: List item 0 has incompatible type "str"; expected "int"
a = ['']
reveal_type(d.get('x', a)) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodInvalidArgs]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.get() # E: All overload variants of "get" of "Mapping" require at least one argument \
        # N: Possible overload variants: \
        # N:     def get(self, k: str) -> object \
        # N:     def [V] get(self, k: str, default: object) -> object
d.get('x', 1, 2) # E: No overload variant of "get" of "Mapping" matches argument types "str", "int", "int" \
                 # N: Possible overload variants: \
                 # N:     def get(self, k: str) -> object \
                 # N:     def [V] get(self, k: str, default: Union[int, V]) -> object
x = d.get('z')
reveal_type(x) # N: Revealed type is "builtins.object"
s = ''
y = d.get(s)
reveal_type(y) # N: Revealed type is "builtins.object"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictMissingMethod]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.bad(1) # E: "D" has no attribute "bad"
[builtins fixtures/dict.pyi]

[case testTypedDictChainedGetMethodWithDictFallback]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
E = TypedDict('E', {'d': D})
p = E(d=D(x=0, y=''))
reveal_type(p.get('d', {'x': 1, 'y': ''})) # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetDefaultParameterStillTypeChecked]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p.get('x', 1 + 'y')     # E: Unsupported operand types for + ("int" and "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictChainedGetWithEmptyDictDefault]
# flags: --strict-optional
from mypy_extensions import TypedDict
C = TypedDict('C', {'a': int})
D = TypedDict('D', {'x': C, 'y': str})
d: D
reveal_type(d.get('x', {})) \
    # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
reveal_type(d.get('x', None)) \
    # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), None]"
reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "Union[builtins.int, None]"
reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Totality (the "total" keyword argument)

[case testTypedDictWithTotalTrue]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=True)
d: D
reveal_type(d) \
    # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})"
[builtins fixtures/dict.pyi]

[case testTypedDictWithInvalidTotalArgument]
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int}, total=0) # E: "total" argument must be a True or False literal
B = TypedDict('B', {'x': int}, total=bool) # E: "total" argument must be a True or False literal
C = TypedDict('C', {'x': int}, x=False) # E: Unexpected keyword argument "x" for "TypedDict"
D = TypedDict('D', {'x': int}, False) # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testTypedDictWithTotalFalse]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None:
    reveal_type(d) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
f({})
f({'x': 1})
f({'y': ''})
f({'x': 1, 'y': ''})
f({'x': 1, 'z': ''}) # E: Extra key "z" for TypedDict "D"
f({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictConstructorWithTotalFalse]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None: pass
reveal_type(D()) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
reveal_type(D(x=1)) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
f(D(y=''))
f(D(x=1, y=''))
f(D(x=1, z='')) # E: Extra key "z" for TypedDict "D"
f(D(x='')) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictIndexingWithNonRequiredKey]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
d: D
reveal_type(d['x']) # N: Revealed type is "builtins.int"
reveal_type(d['y']) # N: Revealed type is "builtins.str"
reveal_type(d.get('x')) # N: Revealed type is "builtins.int"
reveal_type(d.get('y')) # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictSubtypingWithTotalFalse]
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
def fa(a: A) -> None: pass
def fb(b: B) -> None: pass
def fc(c: C) -> None: pass
a: A
b: B
c: C
fb(b)
fc(c)
fb(c)
fb(a) # E: Argument 1 to "fb" has incompatible type "A"; expected "B"
fa(b) # E: Argument 1 to "fa" has incompatible type "B"; expected "A"
fc(b) # E: Argument 1 to "fc" has incompatible type "B"; expected "C"
[builtins fixtures/dict.pyi]

[case testTypedDictJoinWithTotalFalse]
from typing import TypeVar
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
T = TypeVar('T')
def j(x: T, y: T) -> T: return x
a: A
b: B
c: C
reveal_type(j(a, b)) \
    # N: Revealed type is "TypedDict({})"
reveal_type(j(b, b)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
reveal_type(j(c, c)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y'?: builtins.str})"
reveal_type(j(b, c)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
reveal_type(j(c, b)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
[builtins fixtures/dict.pyi]

[case testTypedDictClassWithTotalArgument]
from mypy_extensions import TypedDict
class D(TypedDict, total=False):
    x: int
    y: str
d: D
reveal_type(d) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
[builtins fixtures/dict.pyi]

[case testTypedDictClassWithInvalidTotalArgument]
from mypy_extensions import TypedDict
class D(TypedDict, total=1): # E: "total" argument must be a True or False literal
    x: int
class E(TypedDict, total=bool): # E: "total" argument must be a True or False literal
    x: int
class F(TypedDict, total=xyz): # E: Name "xyz" is not defined \
                               # E: "total" argument must be a True or False literal
    x: int
[builtins fixtures/dict.pyi]

[case testTypedDictClassInheritanceWithTotalArgument]
from mypy_extensions import TypedDict
class A(TypedDict):
    x: int
class B(TypedDict, A, total=False):
    y: int
class C(TypedDict, B, total=True):
    z: str
c: C
reveal_type(c) # N: Revealed type is "TypedDict('__main__.C', {'x': builtins.int, 'y'?: builtins.int, 'z': builtins.str})"
[builtins fixtures/dict.pyi]

[case testNonTotalTypedDictInErrorMessages]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str}, total=False)
B = TypedDict('B', {'x': int, 'z': str, 'a': int}, total=False)
C = TypedDict('C', {'x': int, 'z': str, 'a': str}, total=False)
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int, 'z'?: str})]"; expected "A"
[builtins fixtures/dict.pyi]

[case testNonTotalTypedDictCanBeEmpty]
# flags: --warn-unreachable
from mypy_extensions import TypedDict

class A(TypedDict):
    ...

class B(TypedDict, total=False):
    x: int

a: A = {}
b: B = {}

if not a:
    reveal_type(a) # N: Revealed type is "TypedDict('__main__.A', {})"

if not b:
    reveal_type(b) # N: Revealed type is "TypedDict('__main__.B', {'x'?: builtins.int})"
[builtins fixtures/dict.pyi]

-- Create Type (Errors)

[case testCannotCreateTypedDictTypeWithTooFewArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point')  # E: Too few arguments for TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithTooManyArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int}, dict)  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName]
from mypy_extensions import TypedDict
Point = TypedDict(dict, {'x': int, 'y': int})  # E: TypedDict() expects a string literal as the first argument
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x'})  # E: TypedDict() expects a dictionary literal as the second argument
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithKwargs]
from mypy_extensions import TypedDict
d = {'x': int, 'y': int}
Point = TypedDict('Point', {**d})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithBytes]
from mypy_extensions import TypedDict
Point = TypedDict(b'Point', {'x': int, 'y': int})  # E: TypedDict() expects a string literal as the first argument
# This technically works at runtime but doesn't make sense.
Point2 = TypedDict('Point2', {b'x': int})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]

-- NOTE: The following code works at runtime but is not yet supported by mypy.
--       Keyword arguments may potentially be supported in the future.
[case testCannotCreateTypedDictTypeWithNonpositionalArgs]
from mypy_extensions import TypedDict
Point = TypedDict(typename='Point', fields={'x': int, 'y': int})  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {int: int, int: int})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemType]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': 1, 'y': 1})  # E: Invalid type: try using Literal[1] instead?
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName2]
from mypy_extensions import TypedDict
X = TypedDict('Y', {'x': int})  # E: First argument "Y" to TypedDict() does not match variable name "X"
[builtins fixtures/dict.pyi]


-- Overloading

[case testTypedDictOverloading]
from typing import overload, Iterable
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[str]) -> str: ...
@overload
def f(x: int) -> int: ...
def f(x): pass

a: A
reveal_type(f(a))  # N: Revealed type is "builtins.str"
reveal_type(f(1))  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading2]
from typing import overload, Iterable
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[int]) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:13: error: Argument 1 to "f" has incompatible type "A"; expected "Iterable[int]"
main:13: note: Following member(s) of "A" have conflicts:
main:13: note:     Expected:
main:13: note:         def __iter__(self) -> Iterator[int]
main:13: note:     Got:
main:13: note:         def __iter__(self) -> Iterator[str]

[case testTypedDictOverloading3]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)  # E: No overload variant of "f" matches argument type "A" \
      # N: Possible overload variants: \
      # N:     def f(x: str) -> None \
      # N:     def f(x: int) -> None
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading4]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: int) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is "builtins.int"
reveal_type(f(1)) # N: Revealed type is "builtins.str"
f(b) # E: Argument 1 to "f" has incompatible type "B"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading5]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})
C = TypedDict('C', {'y': int})

@overload
def f(x: A) -> None: ...
@overload
def f(x: B) -> None: ...
def f(x): pass

a: A
b: B
c: C
f(a)
f(b)
f(c) # E: Argument 1 to "f" has incompatible type "C"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading6]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: B) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is "builtins.int"
reveal_type(f(b)) # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Special cases

[case testForwardReferenceInTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
X = TypedDict('X', {'b': 'B', 'c': 'C'})
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})"
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]

[case testForwardReferenceInClassTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
class X(TypedDict):
    b: 'B'
    c: 'C'
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})"
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]

[case testForwardReferenceToTypedDictInTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
X = TypedDict('X', {'a': 'A'})
A = TypedDict('A', {'b': int})
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'a': TypedDict('__main__.A', {'b': builtins.int})})"
reveal_type(x['a']['b']) # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testSelfRecursiveTypedDictInheriting]

from mypy_extensions import TypedDict
# flags: --disable-recursive-aliases
class MovieBase(TypedDict):
    name: str
    year: int

class Movie(MovieBase):
    director: 'Movie' # E: Cannot resolve name "Movie" (possible cyclic definition)

m: Movie
reveal_type(m['director']['name']) # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]
[out]

[case testSubclassOfRecursiveTypedDict]
# flags: --disable-recursive-aliases
from typing import List
from mypy_extensions import TypedDict

class Command(TypedDict):
    subcommands: List['Command']  # E: Cannot resolve name "Command" (possible cyclic definition)

class HelpCommand(Command):
    pass

hc = HelpCommand(subcommands=[])
reveal_type(hc)  # N: Revealed type is "TypedDict('__main__.HelpCommand', {'subcommands': builtins.list[Any]})"
[builtins fixtures/list.pyi]
[out]

[case testTypedDictForwardAsUpperBound]
from typing import TypeVar, Generic
from mypy_extensions import TypedDict
T = TypeVar('T', bound='M')
class G(Generic[T]):
    x: T

yb: G[int] # E: Type argument "int" of "G" must be a subtype of "M"
yg: G[M]
z: int = G[M]().x['x']  # type: ignore[used-before-def]

class M(TypedDict):
    x: int
[builtins fixtures/dict.pyi]
[out]

[case testTypedDictWithImportCycleForward]
import a
[file a.py]
from mypy_extensions import TypedDict
from b import f

N = TypedDict('N', {'a': str})
[file b.py]
import a

def f(x: a.N) -> None:
    reveal_type(x)
    reveal_type(x['a'])
[builtins fixtures/dict.pyi]
[out]
tmp/b.py:4: note: Revealed type is "TypedDict('a.N', {'a': builtins.str})"
tmp/b.py:5: note: Revealed type is "builtins.str"

[case testTypedDictImportCycle]

import b
[file a.py]
class C:
    pass

from b import tp
x: tp
reveal_type(x['x'])  # N: Revealed type is "builtins.int"

reveal_type(tp)  # N: Revealed type is "def (*, x: builtins.int) -> TypedDict('b.tp', {'x': builtins.int})"
tp(x='no')  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")

[file b.py]
from a import C
from mypy_extensions import TypedDict

tp = TypedDict('tp', {'x': int})
[builtins fixtures/dict.pyi]
[out]

[case testTypedDictAsStarStarArg]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
class B: pass

def f1(x: int, y: str) -> None: ...
def f2(x: int, y: int) -> None: ...
def f3(x: B, y: str) -> None: ...
def f4(x: int) -> None: pass
def f5(x: int, y: str, z: int) -> None: pass
def f6(x: int, z: str) -> None: pass

a: A
f1(**a)
f2(**a) # E: Argument "y" to "f2" has incompatible type "str"; expected "int"
f3(**a) # E: Argument "x" to "f3" has incompatible type "int"; expected "B"
f4(**a) # E: Extra argument "y" from **args for "f4"
f5(**a) # E: Missing positional arguments "y", "z" in call to "f5"
f6(**a) # E: Extra argument "y" from **args for "f6"
f1(1, **a) # E: "f1" gets multiple values for keyword argument "x"
[builtins fixtures/tuple.pyi]

[case testTypedDictAsStarStarArgConstraints]
from typing import TypeVar, Union
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def f1(x: T, y: S) -> Union[T, S]: ...

A = TypedDict('A', {'y': int, 'x': str})
a: A
reveal_type(f1(**a)) # N: Revealed type is "Union[builtins.str, builtins.int]"
[builtins fixtures/tuple.pyi]

[case testTypedDictAsStarStarArgCalleeKwargs]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': str, 'y': str})

def f(**kwargs: str) -> None: ...
def g(x: int, **kwargs: str) -> None: ...

a: A
b: B
f(**a) # E: Argument 1 to "f" has incompatible type "**A"; expected "str"
f(**b)
g(**a)
g(**b) # E: Argument "x" to "g" has incompatible type "str"; expected "int"
g(1, **a) # E: "g" gets multiple values for keyword argument "x"
g(1, **b) # E: "g" gets multiple values for keyword argument "x" \
          # E: Argument "x" to "g" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]

[case testTypedDictAsStarStarTwice]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'z': bytes})
C = TypedDict('C', {'x': str, 'z': bytes})

def f1(x: int, y: str, z: bytes) -> None: ...
def f2(x: int, y: float, z: bytes) -> None: ...
def f3(x: int, y: str, z: float) -> None: ...

a: A
b: B
c: C
f1(**a, **b)
f1(**b, **a)
f2(**a, **b) # E: Argument "y" to "f2" has incompatible type "str"; expected "float"
f3(**a, **b) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f3(**b, **a) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f1(**a, **c) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
f1(**c, **a) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
[builtins fixtures/tuple.pyi]

[case testTypedDictAsStarStarAndDictAsStarStar]
from mypy_extensions import TypedDict
from typing import Any, Dict

TD = TypedDict('TD', {'x': int, 'y': str})

def f1(x: int, y: str, z: bytes) -> None: ...
def f2(x: int, y: str) -> None: ...

td: TD
d = None # type: Dict[Any, Any]

f1(**td, **d)
f1(**d, **td)
f2(**td, **d)
f2(**d, **td)
[builtins fixtures/dict.pyi]

[case testTypedDictNonMappingMethods]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]})
a: A

reveal_type(a.copy()) # N: Revealed type is "TypedDict('__main__.A', {'x': builtins.int, 'y': builtins.list[builtins.int]})"
a.has_key('x') # E: "A" has no attribute "has_key"
# TODO: Better error message
a.clear() # E: "A" has no attribute "clear"

a.setdefault('invalid', 1) # E: TypedDict "A" has no key "invalid"
reveal_type(a.setdefault('x', 1)) # N: Revealed type is "builtins.int"
reveal_type(a.setdefault('y', [])) # N: Revealed type is "builtins.list[builtins.int]"
a.setdefault('y', '') # E: Argument 2 to "setdefault" of "TypedDict" has incompatible type "str"; expected "List[int]"
x = ''
a.setdefault(x, 1) # E: Expected TypedDict key to be string literal
alias = a.setdefault
alias(x, 1) # E: Argument 1 has incompatible type "str"; expected "NoReturn"

a.update({})
a.update({'x': 1})
a.update({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
a.update({'x': 1, 'y': []})
a.update({'x': 1, 'y': [1]})
a.update({'z': 1}) # E: Unexpected TypedDict key "z"
a.update({'z': 1, 'zz': 1}) # E: Unexpected TypedDict keys ("z", "zz")
a.update({'z': 1, 'x': 1}) # E: Expected TypedDict key "x" but found keys ("z", "x")
d = {'x': 1}
a.update(d) # E: Argument 1 to "update" of "TypedDict" has incompatible type "Dict[str, int]"; expected "TypedDict({'x'?: int, 'y'?: List[int]})"
[builtins fixtures/dict.pyi]

[case testTypedDictPopMethod]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

reveal_type(a.pop('x')) # N: Revealed type is "builtins.int"
reveal_type(a.pop('y', [])) # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(a.pop('x', '')) # N: Revealed type is "Union[builtins.int, Literal['']?]"
reveal_type(a.pop('x', (1, 2))) # N: Revealed type is "Union[builtins.int, Tuple[Literal[1]?, Literal[2]?]]"
a.pop('invalid', '') # E: TypedDict "A" has no key "invalid"
b.pop('x') # E: Key "x" of TypedDict "B" cannot be deleted
x = ''
b.pop(x) # E: Expected TypedDict key to be string literal
pop = b.pop
pop('x') # E: Argument 1 has incompatible type "str"; expected "NoReturn"
pop('invalid') # E: Argument 1 has incompatible type "str"; expected "NoReturn"
[builtins fixtures/dict.pyi]

[case testTypedDictDel]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

del a['x']
del a['invalid'] # E: TypedDict "A" has no key "invalid"
del b['x'] # E: Key "x" of TypedDict "B" cannot be deleted
s = ''
del a[s] # E: Expected TypedDict key to be string literal
del b[s] # E: Expected TypedDict key to be string literal
alias = b.__delitem__
alias('x')
alias(s)
[builtins fixtures/dict.pyi]

[case testPluginUnionsOfTypedDicts]
from typing import Union
from mypy_extensions import TypedDict

class TDA(TypedDict):
    a: int
    b: str

class TDB(TypedDict):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.get('a'))  # N: Revealed type is "builtins.int"
reveal_type(td.get('b'))  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(td.get('c'))  # N: Revealed type is "builtins.object"

reveal_type(td['a'])  # N: Revealed type is "builtins.int"
reveal_type(td['b'])  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(td['c'])  # N: Revealed type is "Union[Any, builtins.int]" \
                      # E: TypedDict "TDA" has no key "c"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testPluginUnionsOfTypedDictsNonTotal]
from typing import Union
from mypy_extensions import TypedDict

class TDA(TypedDict, total=False):
    a: int
    b: str

class TDB(TypedDict, total=False):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.pop('a'))  # N: Revealed type is "builtins.int"
reveal_type(td.pop('b'))  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(td.pop('c'))  # E: TypedDict "TDA" has no key "c" \
                          # N: Revealed type is "Union[Any, builtins.int]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithTypingExtensions]
# flags: --python-version 3.6
from typing_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithTypingProper]
# flags: --python-version 3.8
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOptionalUpdate]
from typing import Union
from mypy_extensions import TypedDict

class A(TypedDict):
    x: int

d: Union[A, None]
d.update({'x': 1})
[builtins fixtures/dict.pyi]

[case testTypedDictOverlapWithDict]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: str

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotal]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: int
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict):
    a: str
    b: str

x: Config
x == {}  # E: Non-overlapping equality check (left operand type: "Config", right operand type: "Dict[<nothing>, <nothing>]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict, total=False):
    a: str
    b: str

x: Config
x == {}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonStrKey]
# mypy: strict-equality
from typing import TypedDict, Dict, Union

class Config(TypedDict):
    a: str
    b: str

x: Config
y: Dict[Union[str, int], str]
x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverload]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadBad]
from typing import overload, TypedDict, Dict

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadMappingBad]
from typing import overload, TypedDict, Mapping

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Mapping[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadNonStrKey]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: str
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[int, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstance]
from typing import TypedDict, Union

class User(TypedDict):
    id: int
    name: str

u: Union[str, User]
u2: User

if isinstance(u, dict):
    reveal_type(u)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
else:
    reveal_type(u)  # N: Revealed type is "builtins.str"

assert isinstance(u2, dict)
reveal_type(u2)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstanceABCs]
from typing import TypedDict, Union, Mapping, Iterable

class User(TypedDict):
    id: int
    name: str

u: Union[int, User]
u2: User

if isinstance(u, Iterable):
    reveal_type(u)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
else:
    reveal_type(u)  # N: Revealed type is "builtins.int"

assert isinstance(u2, Mapping)
reveal_type(u2)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testTypedDictLiteralTypeKeyInCreation]
from typing import TypedDict, Final, Literal

class Value(TypedDict):
    num: int

num: Final = 'num'
v: Value = {num: 5}
v = {num: ''}  # E: Incompatible types (expression has type "str", TypedDict item "num" has type "int")

bad: Final = 2
v = {bad: 3}  # E: Expected TypedDict key to be string literal
union: Literal['num', 'foo']
v = {union: 2} # E: Expected TypedDict key to be string literal
num2: Literal['num']
v = {num2: 2}
bad2: Literal['bad']
v = {bad2: 2}  # E: Missing key "num" for TypedDict "Value" \
               # E: Extra key "bad" for TypedDict "Value"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_unionWithList]
from __future__ import annotations
from typing import assert_type, TypedDict, Union
from typing_extensions import final

@final
class D(TypedDict):
    foo: int


d_or_list: D | list[str]

if 'foo' in d_or_list:
    assert_type(d_or_list, Union[D, list[str]])
elif 'bar' in d_or_list:
    assert_type(d_or_list, list[str])
else:
    assert_type(d_or_list, list[str])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_total]
from __future__ import annotations
from typing import assert_type, Literal, TypedDict, TypeVar, Union
from typing_extensions import final

@final
class D1(TypedDict):
    foo: int


@final
class D2(TypedDict):
    bar: int


d: D1 | D2

if 'foo' in d:
    assert_type(d, D1)
else:
    assert_type(d, D2)

foo_or_bar: Literal['foo', 'bar']
if foo_or_bar in d:
    assert_type(d, Union[D1, D2])
else:
    assert_type(d, Union[D1, D2])

foo_or_invalid: Literal['foo', 'invalid']
if foo_or_invalid in d:
    assert_type(d, D1)
    # won't narrow 'foo_or_invalid'
    assert_type(foo_or_invalid, Literal['foo', 'invalid'])
else:
    assert_type(d, Union[D1, D2])
    # won't narrow 'foo_or_invalid'
    assert_type(foo_or_invalid, Literal['foo', 'invalid'])

TD = TypeVar('TD', D1, D2)

def f(arg: TD) -> None:
    value: int
    if 'foo' in arg:
        assert_type(arg['foo'], int)
    else:
        assert_type(arg['bar'], int)


[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_final]
# flags: --warn-unreachable
from __future__ import annotations
from typing import assert_type, TypedDict, Union
from typing_extensions import final

@final
class DFinal(TypedDict):
    foo: int


class DNotFinal(TypedDict):
    bar: int


d_not_final: DNotFinal

if 'bar' in d_not_final:
    assert_type(d_not_final, DNotFinal)
else:
    spam = 'ham'  # E: Statement is unreachable

if 'spam' in d_not_final:
    assert_type(d_not_final, DNotFinal)
else:
    assert_type(d_not_final, DNotFinal)

d_final: DFinal

if 'spam' in d_final:
    spam = 'ham'  # E: Statement is unreachable
else:
    assert_type(d_final, DFinal)

d_union: DFinal | DNotFinal

if 'foo' in d_union:
    assert_type(d_union, Union[DFinal, DNotFinal])
else:
    assert_type(d_union, DNotFinal)

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_partialThroughTotalFalse]
from __future__ import annotations
from typing import assert_type, Literal, TypedDict, Union
from typing_extensions import final

@final
class DTotal(TypedDict):
    required_key: int


@final
class DNotTotal(TypedDict, total=False):
    optional_key: int


d: DTotal | DNotTotal

if 'required_key' in d:
    assert_type(d, DTotal)
else:
    assert_type(d, DNotTotal)

if 'optional_key' in d:
    assert_type(d, DNotTotal)
else:
    assert_type(d, Union[DTotal, DNotTotal])

key: Literal['optional_key', 'required_key']
if key in d:
    assert_type(d, Union[DTotal, DNotTotal])
else:
    assert_type(d, Union[DTotal, DNotTotal])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_partialThroughNotRequired]
from __future__ import annotations
from typing import assert_type, Required, NotRequired, TypedDict, Union
from typing_extensions import final

@final
class D1(TypedDict):
    required_key: Required[int]
    optional_key: NotRequired[int]


@final
class D2(TypedDict):
    abc: int
    xyz: int


d: D1 | D2

if 'required_key' in d:
    assert_type(d, D1)
else:
    assert_type(d, D2)

if 'optional_key' in d:
    assert_type(d, D1)
else:
    assert_type(d, Union[D1, D2])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSubclassFinalTypedDict]
from typing import TypedDict
from typing_extensions import final

@final
class DummyTypedDict(TypedDict):
    int_val: int
    float_val: float
    str_val: str

class SubType(DummyTypedDict): # E: Cannot inherit from final class "DummyTypedDict"
    pass

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSubclassFinalTypedDictWithForwardDeclarations]
from typing import TypedDict
from typing_extensions import final

@final
class DummyTypedDict(TypedDict):
    forward_declared: "ForwardDeclared"

class SubType(DummyTypedDict): # E: Cannot inherit from final class "DummyTypedDict"
    pass

class ForwardDeclared: pass

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictTypeNarrowingWithFinalKey]
from typing import Final, Optional, TypedDict

KEY_NAME: Final = "bar"
class Foo(TypedDict):
    bar: Optional[str]

foo = Foo(bar="hello")
if foo["bar"] is not None:
    reveal_type(foo["bar"])     # N: Revealed type is "builtins.str"
    reveal_type(foo[KEY_NAME])  # N: Revealed type is "builtins.str"
if foo[KEY_NAME] is not None:
    reveal_type(foo["bar"])     # N: Revealed type is "builtins.str"
    reveal_type(foo[KEY_NAME])  # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardClass]
from mypy_extensions import TypedDict
from typing import Any, List

class Foo(TypedDict):
    bar: Bar
    baz: Bar

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])  # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardFunc]
from mypy_extensions import TypedDict
from typing import Any, List

Foo = TypedDict('Foo', {'bar': 'Bar', 'baz': 'Bar'})

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])   # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardMixed]
from mypy_extensions import TypedDict
from typing import Any, List

Bar = List[Any]

class Foo(TypedDict):
    foo: Toto
    bar: Bar
    baz: Bar

Toto = int

foo: Foo
reveal_type(foo['foo'])  # N: Revealed type is "builtins.int"
reveal_type(foo['bar'])  # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testAssignTypedDictAsAttribute]
from typing import TypedDict

class A:
    def __init__(self) -> None:
        self.b = TypedDict('b', {'x': int, 'y': str})  # E: TypedDict type as attribute is not supported

reveal_type(A().b)  # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsUpperBoundAndIndexedAssign]
from typing import TypeVar, Generic, TypedDict


class BaseDict(TypedDict, total=False):
    foo: int


_DICT_T = TypeVar('_DICT_T', bound=BaseDict)


class SomeGeneric(Generic[_DICT_T]):
    def __init__(self, data: _DICT_T) -> None:
        self._data: _DICT_T = data

    def set_state(self) -> None:
        self._data['foo'] = 1
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictCreatedWithEmptyDict]
from typing import TypedDict

class TD(TypedDict, total=False):
    foo: int
    bar: int

d: TD = dict()
d2: TD = dict(foo=1)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictBytesKey]
from typing import TypedDict

class TD(TypedDict):
    foo: int

d: TD = {b'foo': 2} # E: Expected TypedDict key to be string literal
d[b'foo'] = 3 # E: TypedDict key must be a string literal; expected one of ("foo") \
    # E: Argument 1 to "__setitem__" has incompatible type "bytes"; expected "str"
d[b'foo'] # E: TypedDict key must be a string literal; expected one of ("foo")
d[3] # E: TypedDict key must be a string literal; expected one of ("foo")
d[True] # E: TypedDict key must be a string literal; expected one of ("foo")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUppercaseKey]
from mypy_extensions import TypedDict

Foo = TypedDict('Foo', {'camelCaseKey': str})
value: Foo = {}  # E: Missing key "camelCaseKey" for TypedDict "Foo"
[builtins fixtures/dict.pyi]

-- Required[]

[case testDoesRecognizeRequiredInTypedDictWithClass]
from typing import TypedDict
from typing import Required
class Movie(TypedDict, total=False):
    title: Required[str]
    year: int
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesRecognizeRequiredInTypedDictWithAssignment]
from typing import TypedDict
from typing import Required
Movie = TypedDict('Movie', {
    'title': Required[str],
    'year': int,
}, total=False)
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowRequiredOutsideOfTypedDict]
from typing import Required
x: Required[int] = 42  # E: Required[] can be only used in a TypedDict definition
[typing fixtures/typing-typeddict.pyi]

[case testDoesOnlyAllowRequiredInsideTypedDictAtTopLevel]
from typing import TypedDict
from typing import Union
from typing import Required
Movie = TypedDict('Movie', {
    'title': Union[
        Required[str],  # E: Required[] can be only used in a TypedDict definition
        bytes
    ],
    'year': int,
}, total=False)
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowRequiredInsideRequired]
from typing import TypedDict
from typing import Union
from typing import Required
Movie = TypedDict('Movie', {
    'title': Required[Union[
        Required[str],  # E: Required[] can be only used in a TypedDict definition
        bytes
    ]],
    'year': int,
}, total=False)
[typing fixtures/typing-typeddict.pyi]

[case testRequiredOnlyAllowsOneItem]
from typing import TypedDict
from typing import Required
class Movie(TypedDict, total=False):
    title: Required[str, bytes]  # E: Required[] must have exactly one type argument
    year: int
[typing fixtures/typing-typeddict.pyi]

[case testRequiredExplicitAny]
# flags: --disallow-any-explicit
from typing import TypedDict
from typing import Required
Foo = TypedDict("Foo", {"a.x": Required[int]})
[typing fixtures/typing-typeddict.pyi]

-- NotRequired[]

[case testDoesRecognizeNotRequiredInTypedDictWithClass]
from typing import TypedDict
from typing import NotRequired
class Movie(TypedDict):
    title: str
    year: NotRequired[int]
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesRecognizeNotRequiredInTypedDictWithAssignment]
from typing import TypedDict
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': str,
    'year': NotRequired[int],
})
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowNotRequiredOutsideOfTypedDict]
from typing import NotRequired
x: NotRequired[int] = 42  # E: NotRequired[] can be only used in a TypedDict definition
[typing fixtures/typing-typeddict.pyi]

[case testDoesOnlyAllowNotRequiredInsideTypedDictAtTopLevel]
from typing import TypedDict
from typing import Union
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': Union[
        NotRequired[str],  # E: NotRequired[] can be only used in a TypedDict definition
        bytes
    ],
    'year': int,
})
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowNotRequiredInsideNotRequired]
from typing import TypedDict
from typing import Union
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': NotRequired[Union[
        NotRequired[str],  # E: NotRequired[] can be only used in a TypedDict definition
        bytes
    ]],
    'year': int,
})
[typing fixtures/typing-typeddict.pyi]

[case testNotRequiredOnlyAllowsOneItem]
from typing import TypedDict
from typing import NotRequired
class Movie(TypedDict):
    title: NotRequired[str, bytes]  # E: NotRequired[] must have exactly one type argument
    year: int
[typing fixtures/typing-typeddict.pyi]

[case testNotRequiredExplicitAny]
# flags: --disallow-any-explicit
from typing import TypedDict
from typing import NotRequired
Foo = TypedDict("Foo", {"a.x": NotRequired[int]})
[typing fixtures/typing-typeddict.pyi]

-- Union dunders

[case testTypedDictUnionGetItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]) -> str:
    reveal_type(foo["z"])  # N: Revealed type is "builtins.str"
    # ok, but type is incorrect:
    reveal_type(foo.__getitem__("z"))  # N: Revealed type is "builtins.object"

    reveal_type(foo["a"])  # N: Revealed type is "Union[builtins.int, Any]" \
                           # E: TypedDict "Foo2" has no key "a"
    reveal_type(foo["b"])  # N: Revealed type is "Union[Any, builtins.int]" \
                           # E: TypedDict "Foo1" has no key "b"
    reveal_type(foo["missing"])  # N: Revealed type is "Any" \
                                 # E: TypedDict "Foo1" has no key "missing" \
                                 # E: TypedDict "Foo2" has no key "missing"
    reveal_type(foo[1])  # N: Revealed type is "Any" \
                         # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                         # E: TypedDict key must be a string literal; expected one of ("z", "b")

    return foo["z"]
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictUnionSetItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]):
    foo["z"] = "a"  # ok
    foo.__setitem__("z", "a")  # ok

    foo["z"] = 1  # E: Value of "z" has incompatible type "int"; expected "str"

    foo["a"] = 1  # E: TypedDict "Foo2" has no key "a"
    foo["b"] = 2  # E: TypedDict "Foo1" has no key "b"

    foo["missing"] = 1  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    foo[1] = "m"  # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                  # E: TypedDict key must be a string literal; expected one of ("z", "b") \
                  # E: Argument 1 to "__setitem__" has incompatible type "int"; expected "str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictUnionDelItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]):
    del foo["z"]  # E: Key "z" of TypedDict "Foo1" cannot be deleted \
                  # E: Key "z" of TypedDict "Foo2" cannot be deleted
    foo.__delitem__("z")  # E: Key "z" of TypedDict "Foo1" cannot be deleted \
                          # E: Key "z" of TypedDict "Foo2" cannot be deleted

    del foo["a"]  # E: Key "a" of TypedDict "Foo1" cannot be deleted \
                  # E: TypedDict "Foo2" has no key "a"
    del foo["b"]  # E: TypedDict "Foo1" has no key "b" \
                  # E: Key "b" of TypedDict "Foo2" cannot be deleted

    del foo["missing"]  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    del foo[1]  # E: Expected TypedDict key to be string literal \
                # E: Argument 1 to "__delitem__" has incompatible type "int"; expected "str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictTypeVarUnionSetItem]
from typing import TypedDict, Union, TypeVar

F1 = TypeVar('F1', bound='Foo1')
F2 = TypeVar('F2', bound='Foo2')

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[F1, F2]):
    foo["z"] = "a"  # ok
    foo["z"] = 1  # E: Value of "z" has incompatible type "int"; expected "str"

    foo["a"] = 1  # E: TypedDict "Foo2" has no key "a"
    foo["b"] = 2  # E: TypedDict "Foo1" has no key "b"

    foo["missing"] = 1  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    foo[1] = "m"  # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                  # E: TypedDict key must be a string literal; expected one of ("z", "b") \
                  # E: Argument 1 to "__setitem__" has incompatible type "int"; expected "str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictCreation]
from typing import TypedDict, Generic, TypeVar

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    key: int
    value: T

tds: TD[str]
reveal_type(tds)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.str})"

tdi = TD(key=0, value=0)
reveal_type(tdi)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.int})"
TD[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
TD[str]({"key": 0, "value": 0})  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictInference]
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    key: int
    value: T

def foo(x: TD[T]) -> List[T]: ...

reveal_type(foo(TD(key=1, value=2)))  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(foo({"key": 1, "value": 2}))  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(foo(dict(key=1, value=2)))  # N: Revealed type is "builtins.list[builtins.int]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictExtending]
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")
class TD(TypedDict, Generic[T]):
    key: int
    value: T

S = TypeVar("S")
class STD(TD[List[S]]):
    other: S

std: STD[str]
reveal_type(std)  # N: Revealed type is "TypedDict('__main__.STD', {'key': builtins.int, 'value': builtins.list[builtins.str], 'other': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictExtendingErrors]
from typing import TypedDict, Generic, TypeVar

T = TypeVar("T")
class Base(TypedDict, Generic[T]):
    x: T
class Sub(Base[{}]):  # E: Invalid TypedDict type argument \
                      # E: Type expected within [...] \
                      # E: Invalid base class "Base"
    y: int
s: Sub
reveal_type(s)  # N: Revealed type is "TypedDict('__main__.Sub', {'y': builtins.int})"

class Sub2(Base[int, str]):  # E: Invalid number of type arguments for "Base" \
                             # E: "Base" expects 1 type argument, but 2 given
    y: int
s2: Sub2
reveal_type(s2)  # N: Revealed type is "TypedDict('__main__.Sub2', {'x': Any, 'y': builtins.int})"

class Sub3(Base):  # OK
    y: int
s3: Sub3
reveal_type(s3)  # N: Revealed type is "TypedDict('__main__.Sub3', {'x': Any, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAttributeOnClassObject]
from typing import TypedDict

class TD(TypedDict):
    x: str
    y: str

reveal_type(TD.__iter__)  # N: Revealed type is "def (typing._TypedDict) -> typing.Iterator[builtins.str]"
reveal_type(TD.__annotations__)  # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(TD.values)  # N: Revealed type is "def (self: typing.Mapping[T`1, T_co`2]) -> typing.Iterable[T_co`2]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictAlias]
# flags: --disallow-any-generics
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")
class TD(TypedDict, Generic[T]):
    key: int
    value: T

Alias = TD[List[T]]

ad: Alias[str]
reveal_type(ad)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.list[builtins.str]})"
Alias[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "List[str]")

# Generic aliases are *always* filled with Any, so this is different from TD(...) call.
Alias(key=0, value=0)  # E: Missing type parameters for generic type "Alias" \
                       # E: Incompatible types (expression has type "int", TypedDict item "value" has type "List[Any]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictMultipleGenerics]
# See https://github.com/python/mypy/issues/13755
from typing import Generic, TypeVar, TypedDict

T = TypeVar("T")
Foo = TypedDict("Foo", {"bar": T})
class Stack(Generic[T]): pass

a = Foo[str]
b = Foo[int]
reveal_type(a)  # N: Revealed type is "def (*, bar: builtins.str) -> TypedDict('__main__.Foo', {'bar': builtins.str})"
reveal_type(b)  # N: Revealed type is "def (*, bar: builtins.int) -> TypedDict('__main__.Foo', {'bar': builtins.int})"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictCallSyntax]
from typing import TypedDict, TypeVar

T = TypeVar("T")
TD = TypedDict("TD", {"key": int, "value": T})
reveal_type(TD)  # N: Revealed type is "def [T] (*, key: builtins.int, value: T`1) -> TypedDict('__main__.TD', {'key': builtins.int, 'value': T`1})"

tds: TD[str]
reveal_type(tds)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.str})"

tdi = TD(key=0, value=0)
reveal_type(tdi)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.int})"
TD[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
TD[str]({"key": 0, "value": 0})  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictSelfItemNotAllowed]
from typing import Self, TypedDict, Optional

class TD(TypedDict):
    val: int
    next: Optional[Self]  # E: Self type cannot be used in TypedDict item type
TDC = TypedDict("TDC", {"val": int, "next": Optional[Self]})  # E: Self type cannot be used in TypedDict item type

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsInferred]
from typing import TypedDict, Dict

D = TypedDict("D", {"foo": int}, total=False)

def f(d: Dict[str, D]) -> None:
    args = d["a"]
    args.update(d.get("b", {}))  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsDeclared]
from typing import TypedDict, Union

class A(TypedDict, total=False):
    name: str
class B(TypedDict, total=False):
    name: str

def foo(data: Union[A, B]) -> None: ...
foo({"name": "Robert"})  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsEmpty]
from typing import TypedDict, Union

class Foo(TypedDict, total=False):
    foo: str
class Bar(TypedDict, total=False):
    bar: str

def foo(body: Union[Foo, Bar] = {}) -> None:  # OK
    ...
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsDistinct]
from typing import TypedDict, Union, Literal

class A(TypedDict):
    type: Literal['a']
    value: bool
class B(TypedDict):
    type: Literal['b']
    value: str

Response = Union[A, B]
def method(message: Response) -> None: ...

method({'type': 'a', 'value': True})  # OK
method({'type': 'b', 'value': 'abc'})  # OK
method({'type': 'a', 'value': 'abc'})  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                                       # E: Argument 1 to "method" has incompatible type "Dict[str, str]"; expected "Union[A, B]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsNested]
from typing import TypedDict, Union

class A(TypedDict, total=False):
    foo: C
class B(TypedDict, total=False):
    foo: D
class C(TypedDict, total=False):
    c: str
class D(TypedDict, total=False):
    d: str

def foo(data: Union[A, B]) -> None: ...
foo({"foo": {"c": "foo"}})  # OK
foo({"foo": {"e": "foo"}})  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                            # E: Argument 1 to "foo" has incompatible type "Dict[str, Dict[str, str]]"; expected "Union[A, B]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictMissingEmptyKey]
from typing_extensions import TypedDict

class A(TypedDict):
    my_attr_1: str
    my_attr_2: int

d: A
d['']  # E: TypedDict "A" has no key ""
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
